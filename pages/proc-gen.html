<!DOCTYPE html>
<html>
<head>
    <link href="../style.css" rel="stylesheet">
    <title id="tabTitlePG">Procedural Generation</title>
</head>
<body>
    <div style="display: flex; flex-direction: column; width: 100%; justify-content: center; align-items: center;">
        <h2 style="text-align: center;">Procedural Generation</h2>
        <canvas id="proceduralCanvas" style="width: 512px; height: 512px; background-color: aliceblue;"></canvas>
        <img id="colourMap" src="../images/colourMap.png" style="display: none; width:8px; height: 8px;">
        <canvas id="colourCanvas" style="display: none;"></canvas>
        <button onClick="drawPerlin()">Redraw</button>
        <br>
        <div style="display: flex; flex-direction: row; gap: 24px;">
            <div>
                <h3>Temperature</h3>
                <div>
                    <label>Scale</label>
                    <input id="sliderS" type="range" min="0" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 1)">
                    <label id="sliderSLabel">0.5</label>
                </div>
                <div>
                    <label>Frequency</label>
                    <input id="sliderF" type="range" min="0.01" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 2)">
                    <label id="sliderFLabel">0.5</label>
                </div>
                <div>
                    <label>Octaves</label>
                    <input id="sliderO" type="range" min="1" max="10" value="5" step="1" onInput="updateValue(this.value, 3)">
                    <label id="sliderOLabel">5</label>
                </div>
                <div>
                    <label>Persistence</label>
                    <input id="sliderP" type="range" min="0.01" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 4)">
                    <label id="sliderPLabel">0.5</label>
                </div>
                <div>
                    <label>Amplitude</label>
                    <input id="sliderA" type="range" min="0.01" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 5)">
                    <label id="sliderALabel">0.5</label>
                </div>
            </div>
            <div>
                <h3>Precipitation</h3>
                <div>
                    <label>Scale</label>
                    <input id="sliderS2" type="range" min="0.01" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 6)">
                    <label id="sliderS2Label">0.5</label>
                </div>
                <div>
                    <label>Frequency</label>
                    <input id="sliderF2" type="range" min="0.01" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 7)">
                    <label id="sliderF2Label">0.5</label>
                </div>
                <div>
                    <label>Octaves</label>
                    <input id="sliderO2" type="range" min="1" max="10" value="5" step="1" onInput="updateValue(this.value, 8)">
                    <label id="sliderO2Label">5</label>
                </div>
                <div>
                    <label>Persistence</label>
                    <input id="sliderP2" type="range" min="0.01" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 9)">
                    <label id="sliderP2Label">0.5</label>
                </div>
                <div>
                    <label>Amplitude</label>
                    <input id="sliderA2" type="range" min="0.01" max="1" value="0.5" step="0.01" onInput="updateValue(this.value, 10)">
                    <label id="sliderA2Label">0.5</label>
                </div>
            </div>
        </div>
        <div style="width: 90%; height: 2px; background-color: white; margin: 32px;"></div>
        <h3>Dynamic Tiles (WIP)</h3>
        <div style="display: flex; flex-direction: row;">
            <canvas id="tileCanvas" style="width: 256px; height: 256px; background-color: blue;"></canvas>
            <p style="max-width: 200px; word-wrap: normal;">These are entirely code generated.
                Using overlapping perlin maps to determine temperature and precipitation, it pulls a colour
                from a carefully constructed biome colour map, and assigns colour similarly to UV textures.
            </p>
        </div>
        <div>
            <label>Tile Count</label>
            <input id="tileCountSlider" type="range" min="0" max="20" value="2" step="1" onInput="updateValue(this.value, 11)">
            <label id="tileCountValue">2</label>
        </div>
        <div style="height: 800px;"></div>
    </div>
</body>
</html>
<script src="../js/utils.js"></script>
<script src="../js/canvasUtils.js"></script>
<script src="../js/perlin.js"></script>
<script src="../js/proc-gen/colourMap.js"></script>
<script>

const gridCount = 64;
const canvas = l("proceduralCanvas");
const ctx_pg = canvas.getContext("2d");
const canvasWidth = getCanvasWidth(canvas);
const squareSize = getCanvasGridSquareSize(canvas, canvasWidth, gridCount);

const colourMapCanvas = l("colourCanvas");
const img = l("colourMap");
const ctx_cm = colourMapCanvas.getContext("2d", { willReadFrequently: true });

let tileGridCount = 2;
const tileCanvas = l("tileCanvas");
const ctx_tc = tileCanvas.getContext('2d');
const tileCanvasWidth = getCanvasWidth(tileCanvas);
const tileSquareSize = getCanvasGridSquareSize(tileCanvas, tileCanvasWidth, tileGridCount);

const sliderSValue = l("sliderSLabel");
const sliderFValue = l("sliderFLabel");
const sliderOValue = l("sliderOLabel");
const sliderPValue = l("sliderPLabel");
const sliderAValue = l("sliderALabel");

const sliderS2Value = l("sliderS2Label");
const sliderF2Value = l("sliderF2Label");
const sliderO2Value = l("sliderO2Label");
const sliderP2Value = l("sliderP2Label");
const sliderA2Value = l("sliderA2Label");

const tileCountValue = l("tileCountValue");

let _s = 0.3;
let _f = 0.2;
let _o = 2;
let _p = 0.7;
let _a = 1;

let _s2 = 0.3;
let _f2 = 0.3;
let _o2 = 2;
let _p2 = 1;
let _a2 = 1;

function updateValue(value, id){
    switch(id){
        case(1):
            sliderSValue.textContent = value;
            _s = parseFloat(value);
            drawPerlin();
            break;
        case(2):
            sliderFValue.textContent = value;
            _f = parseFloat(value);
            drawPerlin();
            break;
        case(3):
            sliderOValue.textContent = value;
            _o = parseFloat(value);
            drawPerlin();
            break;
        case(4):
            sliderPValue.textContent = value;
            _p = parseFloat(value);
            drawPerlin();
            break;
        case(5):
            sliderAValue.textContent = value;
            _a = parseFloat(value);
            drawPerlin();
            break;
        case(6):
            sliderS2Value.textContent = value;
            _s2 = parseFloat(value);
            drawPerlin();
            break;
        case(7):
            sliderF2Value.textContent = value;
            _f2 = parseFloat(value);
            drawPerlin();
            break;
        case(8):
            sliderO2Value.textContent = value;
            _o2 = parseFloat(value);
            drawPerlin();
            break;
        case(9):
            sliderP2Value.textContent = value;
            _p2 = parseFloat(value);
            drawPerlin();
            break;
        case(10):
            sliderA2Value.textContent = value;
            _a2 = parseFloat(value);
            drawPerlin();
            break;
        case(11):
            tileCountValue.textContent = value;
            tileGridCount = value;
            drawTile();
            break;
    }
}

// img.crossOrigin = "same-origin";

let tempMap = [];
let precMap = [];

const COLOURS = [
    'rgb(1,1,1)',
    'rgb(20,20,20)',
    'rgb(40,40,40)',
    'rgb(60,60,60)',
    'rgb(80,80,80)',
    'rgb(90,90,90)',
    'rgb(100,100,100)',
    'rgb(120,120,120)',
    'rgb(130,130,130)',
    'rgb(140,140,140)',
    'rgb(160,160,160)',
    'rgb(180,180,180)',
    'rgb(200,200,200)',
    'rgb(220,220,220)',
    'rgb(240,240,240)',
    'rgb(255,255,255)',
]

const UV_COORDS = [
    [[0,0],[1,0],[0,1]],
    [[2,0],[2,1],[3,1],[3,2]],
    [[3,0],[4,0],[4,1],[5,1],[5,2]],
    [[5,0],[6,0],[7,0],[7,1]],
    [[1,1],[0,2],[1,2],[0,3],[0,4]],
    [[2,2],[1,3],[2,3],[2,4]],
    [[4,2],[3,3],[4,3],[5,3]],
    [[6,1],[6,2],[7,2],[7,3]],
    [[1,4],[0,5],[1,5],[1,6]],
    [[3,4],[2,5],[3,5],[2,6]],
    [[4,4],[4,5],[5,5]],
    [[6,3],[5,4],[6,4],[7,4],[6,5],[7,5]],
    [[0,6],[0,7],[1,7]],
    [[3,6],[2,7],[3,7]],
    [[4,6],[5,6],[6,6],[4,7]],
    [[7,6],[5,7],[6,7],[7,7]]
]

function loadCanvas(){
    colourMapCanvas.width = img.width;
    colourMapCanvas.height = img.height;

    ctx_cm.drawImage(img, 0, 0);
}

loadCanvas();

function drawPerlin(){
    let scale = _s
    let seed = Math.floor((Math.random()) * 255);
    for(let y = 0; y < gridCount; y++){
        tempMap[y] = [];
        precMap[y] = [];
        for(let x = 0; x < gridCount; x++){
            // const value = octavePerlin(x * scale, y * scale, seed * scale, 0.5, 1, 0.5, 0.5);
            const temperature =     octavePerlin(x * _s2, y * _s2, seed * _s2, _o, _p, _f, _a);
            const precipitation =   octavePerlin(x * _s2, y * _s2, seed * _s2, _o2, _p2, _f2, _a2);

            tempMap[y][x] = Math.max(0, Math.min(Math.ceil((temperature + 1 / 2) * 16), 15));
            precMap[y][x] = Math.max(0, Math.min(Math.ceil((precipitation + 1 / 2) * 16), 15));
            
            output = getColour(tempMap[y][x], precMap[y][x]);
            mark(ctx_pg, x, y, output, squareSize);
        }
    }
    console.log("Drawn Perlin");
}

function drawTile() {
    const tileSize = tileCanvasWidth / tileGridCount;
    const pixelSize = tileSize / 8;

    
    for(let x = 0; x < tileGridCount; x++){
        for(let y = 0; y < tileGridCount; y++){
            for(let i = 0; i < UV_COORDS.length; i++){
                for(const [fx, fy] of UV_COORDS[i]){
                    // console.log(`X: ${x}, Y: ${y}, sub-X: ${fx}, sub-Y: ${fy}.`);
                    ctx_tc.fillStyle = COLOURS[i];
                    ctx_tc.fillRect((fx * pixelSize) + (x * tileSize), (fy * pixelSize) + (y * tileSize), pixelSize + 1, pixelSize + 1);
                }
            }
            console.log("Drawn Tile.");
        }
    }
    

    //mark(ctx_tc, fx, fy, colourMap[y * 16 + x], Math.floor(squareSize / 8));
}


function bilerp(tl, tr, bl, br, x, y) {
    const top = tl + (tr - tl) * x;
    const bottom = bl + (br - bl) * x;
    return top + (bottom - top) * y;
}

function getDataSafe(tempMap, precMap, x, y) {
    const gx = Math.max(0, Math.min(gridCount - 1, x));
    const gy = Math.max(0, Math.min(gridCount - 1, y));
    return {
        temp: tempMap[gy][gx],
        prec: precMap[gy][gx]
    };
}

function createTile(temperature, precipitation, x, y){
    // use normalised values to read colourmap.
    const c = getColour(temperature, precipitation);
    const colour = `rgb(${c.r},${c.g},${c.b})`;

    mark(ctx_pg, x, y, colour, squareSize);
}

function getColour(x, y){
    
    const index = y * 16 + x;
    const c = colourMap[index];

    // console.log(`Index ${index} of colourMap returned ${colour}.`);

    if(c === undefined) console.log("Botched.");
    // else{ console.log(c); }
    const colour = undefined ? "rgb(1,1,1)" : `rgb(${c.r},${c.g},${c.b})`;

    return colour;
}

function getColourSet(tempMap, precMap){
    // Log and calculate colours of surrounding tiles.
    // Return a 16 colour set that corresponds with the UV coords.
}

function mapValueToRange(val, rng){
    const normalised = (val + 1) / 2;
    const index = Math.floor(normalised * (rng.length - 1));
    return rng[index];
}

function getCanvasWidth(_canvas){
    return parseFloat(getComputedStyle(_canvas).width);
}

drawPerlin();
drawTile();
// drawCheckerboard(canvas, canvasWidth, 32);

</script>