<!DOCTYPE html>
<html>
<head>
    <link href="../style.css" rel="stylesheet">
    <title id="tabTitleQ">Quay</title>
</head>
<body>
    <div class="slice">
        <h1>Quay</h1>
    </div>
    <div class="slice" style="align-items: center; flex-direction: column; gap: 8px;">
            <canvas id="checkerboard" style="margin: 32px"></canvas>
            <label id="debug1">Test</label>
            <label id="debug2">Test 2</label>
            <input id="toEncode">
            <button id="generateBtn" onclick="generateCode()">Generate</button>
            <button onclick="downloadCanvas(l('checkerboard'))">Download PNG</button>
    </div>
</body>
</html>
<script src="../utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@bnb-chain/reed-solomon/dist/index.aio.js"></script>
<script>

const canvas = l("checkerboard");
const ctx = canvas.getContext("2d");

let gridSize = 14;
let squareSize = 450 / gridSize;

let rawText;

const inputField = l("toEncode");
const debug1 = l("debug1");
const debug2 = l("debug2");

const rs = new RS.ReedSolomon();

canvas.width = gridSize * squareSize;
canvas.height = gridSize * squareSize;

async function generateCode(){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    parity = preprocessInputText();
    drawSection(COLOURS.C, SIZE.Frame)
    var encoded = await processToFinalText(rawText, parity);
    debug2.textContent = encoded + " -- Parity: " + parity;
    // drawCheckerboard();
}

function drawCheckerboard() {
	for (let y = 0; y < gridSize; y++) {
		for (let x = 0; x < gridSize; x++) {
			// Alternate colors
			let colour = (x + y) % 2 === 0 ? "#ffbb69ff" : "#D64E6E";
			mark(x, y, colour);
		}
	}
}

function mark(x, y, colour){
    ctx.fillStyle = colour;
    ctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
}

const SIZE = {
    Frame: [],
    Whites: [],
    Header: [],
    Data: [],   
}

const COLOURS = {
    C: "#01BAEF",
    M: "#E5446D",
    Y: "#FFC130",
    K: "#2D2A32",
    W: "#F8F4E3"
}

function preprocessInputText(){
    // Determine input field size as an amount of chars.
    // 2 d-bits per symbol, 

    rawText = inputField.value;

    var ar = rawText.split('');
    var input = ar.length;

    var parity = 0;

    if(ar.length < 10){
        gridSize = 7;
        getCoords(input);
        parity = 10 - input;
    }
    else{
        parity =  1;
    }
    debug1.textContent = ar;
    return parity;
}

function getCoords(size){
    // I need to transfer the coordinates over.
    switch(size){
        case 7:
            SIZE.Frame = [[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[0,1],[6,1],[0,2],[6,2],[0,3],[6,3],[0,4],[6,4],[0,5],[6,5],[0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[6,6]];
            SIZE.Whites = [];
            SIZE.Header = [[1,1],[2,1],[3,1],[4,1],[5,1]];
            SIZE.Data = [[1,2],[2,2],[3,2],[4,2],[5,2],[1,3],[2,3],[3,3],[4,3],[5,3],[1,4],[2,4],[3,4],[4,4],[5,4],[1,5],[2,5],[3,5],[4,5],[5,5]];
            break;
    }
}

async function processToFinalText(input, parity){

    const dataBytes = textToUint8Array(input);
    const eccEncoded = await encodeECC(dataBytes, parity);
    const binaryPairs = uint8ArrayToBinaryPairs(eccEncoded);

    debug1.textContent = `Data Bytes: ${dataBytes}, Encoded: ${eccEncoded}, BinaryPairs: ${binaryPairs}`;

    return binaryPairs;
}


function textToUint8Array(text) {
    return new TextEncoder().encode(text);
}

async function encodeECC(data, parityBytes) {
    return await rs.encode(data, parityBytes);
}

function uint8ArrayToBinaryPairs(uint8array) {
    const bitString = [...uint8array]
        .map(byte => byte.toString(2).padStart(8, '0'))
        .join('');

    const pairs = [];
    for (let i = 0; i < bitString.length; i += 2) {
        pairs.push(bitString.slice(i, i + 2));
    }
    return pairs;
}


// function textToBin(text) {
//     return [...text].map(c =>
//         c.charCodeAt().toString(2).padStart(8, '0')
//     ).join('');
// }

// function toPairs(input) {
//     const pairs = [];
//     for (let i = 0; i < input.length; i += 2) {
//         pairs.push(input.substring(i, i + 2));
//     }
//     return pairs;
// }

// function binaryToUint8Array(binaryArray) {
//     const bitString = Array.isArray(binaryArray) ? binaryArray.join('') : binaryArray;
//     const padded = bitString.padEnd(Math.ceil(bitString.length / 8) * 8, '0');
//     const bytes = [];
//     for (let i = 0; i < padded.length; i += 8) {
//         bytes.push(parseInt(padded.slice(i, i + 8), 2));
//     }
//     return new Uint8Array(bytes);
// }

// async function encodeECC(data, parity) {
//     return await rs.encode(data, parity);
// }

// function bytesToBinaryPairs(uint8array) {
//     const bitString = [...uint8array]
//         .map(b => b.toString(2).padStart(8, '0'))
//         .join('');
//     const pairs = [];
//     for (let i = 0; i < bitString.length; i += 2) {
//         pairs.push(bitString.slice(i, i + 2));
//     }
//     return pairs;
// }


const pairToColour = {
    "00": COLOURS.C,
    "01": COLOURS.M,
    "10": COLOURS.Y,
    "11": COLOURS.K
}

function renderColourGrid(binaryPairs){
    for(i = 0; i < binaryPairs.length; i++){
        //
    }
}

function drawSection(colour, coords){
    for(i = 0; i < coords.length; i++){
        mark(coords[i][0], coords[i][1]);
    }
}


function downloadCanvas(canvas, filename = "canvas.png") {
	const link = document.createElement("a");
	link.download = filename;
	link.href = canvas.toDataURL("image/png");
	link.click();
}

</script>